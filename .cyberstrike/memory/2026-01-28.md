# Daily Notes: 2026-01-28

## Session Summary
Major research and implementation session focused on AI agent architecture.

---

## Research: Moltbot Analysis

### Persistent Memory System
Moltbot uses file-based memory:
- `MEMORY.md` - Long-term facts, preferences, decisions
- `memory/YYYY-MM-DD.md` - Daily session notes
- Auto-loaded at session start for continuity

### Tool Handling (Key Discovery)
Moltbot can use 100+ tools because it doesn't load all definitions at once.
- Uses dynamic/lazy loading
- Tool definitions only loaded when relevant
- Keeps context efficient

---

## Research: Claude Code CLI Analysis

### Agent System
- Subagent spawning via Task tool
- Agents: Explore, Plan, general-purpose, Bash
- Each agent has different tool permissions

### Skills System
- Markdown files with YAML frontmatter
- Preloaded into system prompt at startup
- Domain knowledge injection

### MCP Integration
- `mcp.json` configuration file
- Servers expose tools via JSON-RPC
- Problem: All tools loaded = context overflow

### ToolSearch Pattern (Critical Finding)
Instead of including all MCP tool definitions:
```
1. Include ToolSearch meta-tool
2. User asks for capability
3. ToolSearch finds matching tools
4. Tools dynamically loaded for next turn
```

This is how Claude Code handles potentially hundreds of MCP tools.

---

## Implementations Today

### 1. Skills Preload System
- Created `src/skill/index.ts`
- Skills loaded from `.cyberstrike/skills/`
- Agent `skills` field for preloading
- Example skills: owasp-wstg, sql-injection, recon-methodology

### 2. Memory System
- Created `src/memory/index.ts`
- Memory tools: search, write, read, context
- Auto-loading at session start
- Daily notes + long-term memory

### 3. Agent Model Fix
- Made model field optional in agents
- Agents inherit default model
- Fixed "model not valid" error

### 4. Browser Opening Fix
- Changed claude-cli to use `--system-prompt`
- Set default model to opus (not haiku)
- Haiku too conservative for security tasks

### 5. Dynamic Tool Loading System (ToolSearch Pattern)
Implemented the key insight from researching Moltbot and Claude Code.

**New Files:**
- `src/tool/lazy-registry.ts` - Lazy tool metadata storage
- `src/tool/tool-search.ts` - Meta-tools for dynamic loading

**New Tools:**
- `tool_search` - Search for tools by capability
- `load_tools` - Load selected tools into context
- `unload_tools` - Free context budget
- `list_loaded_tools` - Show current tool status

**How It Works:**
```
1. Startup: Only tool metadata collected (name, keywords, summary)
2. User task: "test for SQL injection"
3. Agent: tool_search({ query: "sql injection" })
4. System: Returns matching tool IDs with descriptions
5. Agent: load_tools({ tool_ids: ["sqlmap_scan"] })
6. System: Full tool definition loaded for next turn
7. Agent can now use sqlmap_scan tool
```

**Context Savings:**
- Before: 100 tools × 500 tokens = 50,000 tokens
- After: 4 meta-tools × 500 = 2,000 tokens + on-demand loading
- Savings: ~48,000 tokens freed for conversation

---

## Key Code Patterns Learned

### Lazy Tool Loading Pattern
```typescript
interface LazyTool {
  id: string
  keywords: string[]      // For searching
  summary: string         // Minimal context cost
  load: () => FullTool    // Full definition on demand
}

class ToolRegistry {
  available: Map<string, LazyTool>  // All tools (metadata only)
  loaded: Set<string>               // Currently in context

  search(query: string): LazyTool[]
  loadTools(ids: string[]): void
  unloadTools(ids: string[]): void
}
```

### Tool Search Meta-Tool Pattern
```typescript
ToolSearch = Tool.define("tool_search", {
  description: "Find tools by capability description",
  parameters: { query: z.string() },
  execute: async ({ query }) => {
    const matches = registry.search(query)
    // System loads these tools for next turn
    return formatToolList(matches)
  }
})
```

### Context Budget Management
```typescript
const TOOL_CONTEXT_BUDGET = 20000 // tokens

function canLoadTool(tool: LazyTool): boolean {
  const currentUsage = calculateToolTokens(loaded)
  const toolCost = estimateTokens(tool)
  return currentUsage + toolCost < TOOL_CONTEXT_BUDGET
}
```

---

## Errors Fixed Today

1. **SkillTool API mismatch**: `Skill.all()` didn't exist, added compatibility layer
2. **Template literal escape**: Heredoc created `\`${name}.md\`` instead of proper template
3. **Model validation**: Hardcoded invalid model IDs in agent markdown files

---

## Next Steps

1. [x] Implement dynamic tool loading system ✓
2. [x] Create ToolSearch meta-tool for MCP ✓
3. [ ] Add tool usage metrics
4. [ ] Test with multiple MCP servers
5. [ ] Write blog post about tool scaling

---

## Content Ideas for Blog/YouTube

### Title Options
- "Scaling AI Agents to 100+ Tools: The Pattern Nobody Talks About"
- "Why Your MCP Integration Will Break (And How to Fix It)"
- "Building Production AI Agents: Lessons from Moltbot and Claude Code"

### Key Points to Cover
1. Context window is finite (~200K tokens)
2. Tool definitions eat context (500+ tokens each)
3. Naive approach: Load all tools = context overflow
4. Solution: Lazy loading + Tool Search pattern
5. Implementation walkthrough

### Demo Script
```
1. Show naive MCP with 50 tools → context warning
2. Implement ToolSearch pattern
3. Same 50 tools but dynamic loading
4. Show context usage before/after
```
