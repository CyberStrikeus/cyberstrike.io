---
title: OAuth Configuration
description: Configure OAuth authentication for MCP servers
sidebar:
  order: 4
  label: OAuth
---

OAuth enables secure authentication with third-party MCP servers without sharing credentials directly.

{/* TODO: Diagram - OAuth flow */}
<div className="border-2 border-dashed border-gray-400 dark:border-gray-600 rounded-lg p-8 my-6 text-center bg-gray-100 dark:bg-gray-800">
  <p className="text-gray-500 dark:text-gray-400 font-mono text-sm">ðŸ“Š DIAGRAM: oauth-flow.mmd</p>
  <p className="text-gray-400 dark:text-gray-500 text-xs mt-2">OAuth authentication flow</p>
</div>

## Overview

OAuth in Cyberstrike:

- Secure token-based authentication
- Browser-based authorization
- Automatic token refresh
- Scope-based permissions
- Support for OAuth 2.0 and OIDC

## OAuth 2.0 Configuration

### Basic Setup

```json title="~/.cyberstrike/config.json"
{
  "mcp": {
    "servers": {
      "oauth-service": {
        "url": "https://mcp.service.com/sse",
        "oauth": {
          "clientId": "{env:OAUTH_CLIENT_ID}",
          "authorizationUrl": "https://auth.service.com/authorize",
          "tokenUrl": "https://auth.service.com/token"
        }
      }
    }
  }
}
```

### With Scopes

```json
{
  "mcp": {
    "servers": {
      "github-mcp": {
        "url": "https://mcp.github.com/sse",
        "oauth": {
          "clientId": "{env:GH_CLIENT_ID}",
          "authorizationUrl": "https://github.com/login/oauth/authorize",
          "tokenUrl": "https://github.com/login/oauth/access_token",
          "scope": "repo read:user read:org"
        }
      }
    }
  }
}
```

### With Client Secret

```json
{
  "mcp": {
    "servers": {
      "private-service": {
        "url": "https://mcp.private.com/sse",
        "oauth": {
          "clientId": "{env:OAUTH_CLIENT_ID}",
          "clientSecret": "{env:OAUTH_CLIENT_SECRET}",
          "authorizationUrl": "https://auth.private.com/authorize",
          "tokenUrl": "https://auth.private.com/token"
        }
      }
    }
  }
}
```

## Authorization Flow

### Interactive Login

When connecting to an OAuth-protected server:

1. Cyberstrike opens browser to authorization URL
2. User logs in and grants permissions
3. Browser redirects with authorization code
4. Cyberstrike exchanges code for tokens
5. Tokens are stored securely

### Command Line Trigger

```bash
cyberstrike mcp auth github-mcp
```

### In-Session

```
> Connect to the GitHub MCP server
```

Cyberstrike will prompt for authorization if needed.

## Token Management

### Token Storage

Tokens are stored in:

```
~/.cyberstrike/auth/
  mcp-github-tokens.json
  mcp-private-tokens.json
```

### Token Refresh

Automatic refresh when:
- Access token expires
- Refresh token is available
- Server returns 401

### Manual Refresh

```bash
cyberstrike mcp refresh github-mcp
```

### Token Revocation

```bash
cyberstrike mcp logout github-mcp
```

## PKCE Support

For public clients (recommended):

```json
{
  "mcp": {
    "servers": {
      "pkce-service": {
        "url": "https://mcp.service.com/sse",
        "oauth": {
          "clientId": "{env:CLIENT_ID}",
          "authorizationUrl": "https://auth.service.com/authorize",
          "tokenUrl": "https://auth.service.com/token",
          "pkce": true
        }
      }
    }
  }
}
```

PKCE (Proof Key for Code Exchange) adds security for public clients.

## Device Authorization

For headless environments:

```json
{
  "mcp": {
    "servers": {
      "device-service": {
        "url": "https://mcp.service.com/sse",
        "oauth": {
          "clientId": "{env:CLIENT_ID}",
          "deviceAuthorizationUrl": "https://auth.service.com/device",
          "tokenUrl": "https://auth.service.com/token",
          "grantType": "device_code"
        }
      }
    }
  }
}
```

### Device Flow

1. Cyberstrike requests device code
2. User visits URL and enters code
3. Cyberstrike polls for token
4. Connection established

## Common Providers

### GitHub

```json
{
  "mcp": {
    "servers": {
      "github": {
        "url": "https://mcp.github.com/sse",
        "oauth": {
          "clientId": "{env:GH_CLIENT_ID}",
          "authorizationUrl": "https://github.com/login/oauth/authorize",
          "tokenUrl": "https://github.com/login/oauth/access_token",
          "scope": "repo read:user"
        }
      }
    }
  }
}
```

### Google

```json
{
  "mcp": {
    "servers": {
      "google": {
        "url": "https://mcp.google.com/sse",
        "oauth": {
          "clientId": "{env:GOOGLE_CLIENT_ID}",
          "clientSecret": "{env:GOOGLE_CLIENT_SECRET}",
          "authorizationUrl": "https://accounts.google.com/o/oauth2/v2/auth",
          "tokenUrl": "https://oauth2.googleapis.com/token",
          "scope": "openid profile email"
        }
      }
    }
  }
}
```

### Microsoft/Azure

```json
{
  "mcp": {
    "servers": {
      "azure": {
        "url": "https://mcp.azure.com/sse",
        "oauth": {
          "clientId": "{env:AZURE_CLIENT_ID}",
          "clientSecret": "{env:AZURE_CLIENT_SECRET}",
          "authorizationUrl": "https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize",
          "tokenUrl": "https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token",
          "scope": "https://graph.microsoft.com/.default"
        }
      }
    }
  }
}
```

### Okta

```json
{
  "mcp": {
    "servers": {
      "okta": {
        "url": "https://mcp.company.com/sse",
        "oauth": {
          "clientId": "{env:OKTA_CLIENT_ID}",
          "authorizationUrl": "https://company.okta.com/oauth2/v1/authorize",
          "tokenUrl": "https://company.okta.com/oauth2/v1/token",
          "scope": "openid profile"
        }
      }
    }
  }
}
```

## Custom Callback Server

### Local Callback

Default callback server:

```
http://localhost:8765/callback
```

### Custom Port

```json
{
  "oauth": {
    "callbackPort": 9000
  }
}
```

### Custom Path

```json
{
  "oauth": {
    "callbackPath": "/oauth/callback"
  }
}
```

## Security Best Practices

### Client Secret Protection

1. Never commit secrets to version control
2. Use environment variables
3. Rotate secrets periodically
4. Use PKCE for public clients

### Token Security

1. Tokens are encrypted at rest
2. Use short-lived access tokens
3. Implement token rotation
4. Revoke tokens on logout

### Scope Minimization

1. Request minimum required scopes
2. Review scope permissions
3. Avoid wildcard scopes
4. Audit scope usage

## Troubleshooting

### Authorization Failed

```
Error: OAuth authorization failed
```

Check:
- Client ID is correct
- Authorization URL is accessible
- Redirect URI is registered

### Token Exchange Failed

```
Error: Token exchange failed
```

Verify:
- Client secret is correct (if required)
- Token URL is accessible
- Grant type is supported

### Token Refresh Failed

```
Error: Token refresh failed
```

Solutions:
- Re-authenticate manually
- Check refresh token validity
- Verify token URL

### Callback Not Received

```
Error: Callback timeout
```

Check:
- Firewall allows localhost connections
- No other app using callback port
- Browser completes authorization

<Aside variant="tip">
  Use PKCE for all public clients. It provides additional security without requiring a client secret.
</Aside>

## Related Documentation

- [Remote Servers](/docs/mcp/remote-servers) - Remote MCP configuration
- [MCP Overview](/docs/mcp) - MCP basics
- [Configuration](/docs/configuration) - Full configuration options
