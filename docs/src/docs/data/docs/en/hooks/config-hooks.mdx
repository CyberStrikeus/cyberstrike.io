---
title: Config Hooks
description: Define hooks in configuration files without writing code
sidebar:
  order: 3
  label: Config Hooks
---

Config hooks allow you to define hook behavior directly in configuration files, running shell commands in response to tool events.

{/* TODO: Screenshot - Config hooks in action */}
<div className="border-2 border-dashed border-gray-400 dark:border-gray-600 rounded-lg p-8 my-6 text-center bg-gray-100 dark:bg-gray-800">
  <p className="text-gray-500 dark:text-gray-400 font-mono text-sm">ðŸ“¸ SCREENSHOT: config-hooks-action.png</p>
  <p className="text-gray-400 dark:text-gray-500 text-xs mt-2">Config hooks blocking a dangerous command</p>
</div>

## Overview

Config hooks:

- Defined in JSON configuration
- Run shell commands
- No code required
- Project-specific customization
- Quick validation logic

## Basic Configuration

```json title="cyberstrike.json"
{
  "hooks": {
    "preToolUse": [
      {
        "matcher": "Bash",
        "command": "./scripts/validate-command.sh"
      }
    ]
  }
}
```

## Hook Events

### PreToolUse

Runs before tool execution:

```json
{
  "hooks": {
    "preToolUse": [
      {
        "matcher": "Bash",
        "command": "./scripts/validate.sh $TOOL_ARGS"
      }
    ]
  }
}
```

### PostToolUse

Runs after tool execution:

```json
{
  "hooks": {
    "postToolUse": [
      {
        "matcher": "Write(*)",
        "command": "npm run lint --fix $TOOL_FILE"
      }
    ]
  }
}
```

### Notification

Runs on events:

```json
{
  "hooks": {
    "notification": [
      {
        "type": "error",
        "command": "./scripts/notify-slack.sh"
      }
    ]
  }
}
```

### Stop

Runs when session stops:

```json
{
  "hooks": {
    "stop": [
      {
        "command": "./scripts/cleanup.sh"
      }
    ]
  }
}
```

### SessionStart

Runs at session start:

```json
{
  "hooks": {
    "sessionStart": [
      {
        "command": "./scripts/init-session.sh"
      }
    ]
  }
}
```

## Matcher Patterns

### Tool Name

```json
{
  "matcher": "Bash"
}
```

### Glob Pattern

```json
{
  "matcher": "Write(src/**/*.ts)"
}
```

### Multiple Tools

```json
{
  "matcher": "Bash|Write|Edit"
}
```

### All Tools

```json
{
  "matcher": "*"
}
```

### Argument Pattern

```json
{
  "matcher": "Bash(npm *)"
}
```

## Environment Variables

Hooks receive context via environment variables:

| Variable | Description |
|----------|-------------|
| `TOOL_NAME` | Name of the tool |
| `TOOL_ARGS` | JSON-encoded arguments |
| `TOOL_FILE` | File path (for file tools) |
| `TOOL_COMMAND` | Command (for Bash) |
| `TOOL_CONTENT` | Content (for Write) |
| `SESSION_ID` | Current session ID |
| `WORKING_DIR` | Working directory |

### Using Variables

```bash title="scripts/validate.sh"
#!/bin/bash
ARGS=$(echo "$TOOL_ARGS" | jq -r '.command')

if [[ "$ARGS" == *"rm -rf"* ]]; then
  echo "BLOCK: Dangerous command detected"
  exit 1
fi

exit 0
```

## Exit Codes

Hook commands control behavior via exit codes:

| Exit Code | Action |
|-----------|--------|
| 0 | Continue execution |
| 1 | Block execution |
| 2 | Skip with warning |

### Example Script

```bash title="scripts/check-command.sh"
#!/bin/bash

# Parse command
CMD="$TOOL_COMMAND"

# Check for dangerous patterns
if [[ "$CMD" =~ (rm -rf|dd if=|mkfs) ]]; then
  echo "Blocked: Dangerous command pattern"
  exit 1
fi

# Check for sudo
if [[ "$CMD" == sudo* ]]; then
  echo "Warning: Sudo command"
  exit 2
fi

# Allow
exit 0
```

## Hook Output

### Standard Output

Hook stdout is displayed to user:

```bash
#!/bin/bash
echo "Validating command..."
# validation logic
echo "Command approved"
exit 0
```

### Standard Error

Hook stderr is logged:

```bash
#!/bin/bash
echo "Error: Invalid command" >&2
exit 1
```

### JSON Response

Return structured data:

```bash
#!/bin/bash
cat <<EOF
{
  "action": "block",
  "message": "Command not allowed",
  "reason": "Contains dangerous pattern"
}
EOF
exit 1
```

## Conditional Hooks

### By File Extension

```json
{
  "hooks": {
    "postToolUse": [
      {
        "matcher": "Write(*.ts)",
        "command": "npx tsc --noEmit $TOOL_FILE"
      },
      {
        "matcher": "Write(*.py)",
        "command": "python -m py_compile $TOOL_FILE"
      }
    ]
  }
}
```

### By Directory

```json
{
  "hooks": {
    "preToolUse": [
      {
        "matcher": "Write(src/secure/**)",
        "command": "./scripts/security-review.sh"
      }
    ]
  }
}
```

## Multiple Hooks

Multiple hooks run in order:

```json
{
  "hooks": {
    "postToolUse": [
      {
        "matcher": "Write(*.ts)",
        "command": "npx eslint --fix $TOOL_FILE"
      },
      {
        "matcher": "Write(*.ts)",
        "command": "npx prettier --write $TOOL_FILE"
      },
      {
        "matcher": "Write(*.ts)",
        "command": "npx tsc --noEmit $TOOL_FILE"
      }
    ]
  }
}
```

## Timeout

### Set Timeout

```json
{
  "hooks": {
    "postToolUse": [
      {
        "matcher": "Write(*)",
        "command": "npm run test",
        "timeout": 30000
      }
    ]
  }
}
```

Timeout in milliseconds (default: 10000).

## Async Execution

### Run in Background

```json
{
  "hooks": {
    "postToolUse": [
      {
        "matcher": "*",
        "command": "./scripts/log-async.sh &",
        "async": true
      }
    ]
  }
}
```

Async hooks don't block execution.

## Examples

### Lint on Write

```json
{
  "hooks": {
    "postToolUse": [
      {
        "matcher": "Write(*.{ts,js,tsx,jsx})",
        "command": "npx eslint --fix $TOOL_FILE && npx prettier --write $TOOL_FILE"
      }
    ]
  }
}
```

### Security Validation

```json
{
  "hooks": {
    "preToolUse": [
      {
        "matcher": "Bash",
        "command": "./scripts/security-check.sh"
      },
      {
        "matcher": "Write(.env*)",
        "command": "echo 'BLOCK: Cannot modify .env files' && exit 1"
      }
    ]
  }
}
```

### Audit Logging

```json
{
  "hooks": {
    "postToolUse": [
      {
        "matcher": "*",
        "command": "echo \"$(date -Iseconds) $TOOL_NAME\" >> .cyberstrike/audit.log",
        "async": true
      }
    ]
  }
}
```

### Auto-Format

```json
{
  "hooks": {
    "postToolUse": [
      {
        "matcher": "Write(*.py)",
        "command": "black $TOOL_FILE && isort $TOOL_FILE"
      },
      {
        "matcher": "Write(*.go)",
        "command": "gofmt -w $TOOL_FILE"
      },
      {
        "matcher": "Write(*.rs)",
        "command": "rustfmt $TOOL_FILE"
      }
    ]
  }
}
```

## Troubleshooting

### Hook Not Running

Check:
- Matcher pattern is correct
- Script is executable (`chmod +x`)
- Path is correct

### Permission Denied

```bash
chmod +x ./scripts/validate.sh
```

### Timeout

Increase timeout or optimize script:

```json
{
  "timeout": 60000
}
```

<Aside variant="caution">
  Long-running hooks can slow down Cyberstrike. Keep hooks fast or run them async.
</Aside>

## Related Documentation

- [Hooks Overview](/docs/hooks) - Hook system basics
- [Plugin Hooks](/docs/hooks/plugin-hooks) - Programmatic hooks
- [Configuration](/docs/configuration) - Config file reference
