---
title: Plugin Hooks
description: Create plugins that hook into Cyberstrike's execution lifecycle
sidebar:
  order: 2
  label: Plugin Hooks
---

Plugin hooks allow you to create reusable extensions that hook into Cyberstrike's tool execution lifecycle.

{/* TODO: Diagram - Plugin hook architecture */}
<div className="border-2 border-dashed border-gray-400 dark:border-gray-600 rounded-lg p-8 my-6 text-center bg-gray-100 dark:bg-gray-800">
  <p className="text-gray-500 dark:text-gray-400 font-mono text-sm">ðŸ“Š DIAGRAM: plugin-hook-architecture.mmd</p>
  <p className="text-gray-400 dark:text-gray-500 text-xs mt-2">Plugin hook execution flow</p>
</div>

## Overview

Plugin hooks are npm packages that:

- Hook into tool execution
- Modify tool behavior
- Add validation logic
- Implement security policies
- Extend functionality

## Plugin Structure

### Basic Plugin

```typescript title="src/index.ts"
import { CyberstrikePlugin, ToolHook } from '@cyberstrike/plugin';

export default class MyPlugin implements CyberstrikePlugin {
  name = 'my-plugin';
  version = '1.0.0';

  hooks: ToolHook[] = [
    {
      event: 'preToolUse',
      matcher: 'Bash',
      handler: async (context) => {
        // Validate command before execution
        if (context.args.command.includes('rm -rf')) {
          return {
            action: 'block',
            message: 'Dangerous command blocked'
          };
        }
        return { action: 'continue' };
      }
    }
  ];
}
```

### Package Structure

```
my-cyberstrike-plugin/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts
â”‚   â””â”€â”€ hooks/
â”‚       â”œâ”€â”€ bash-validator.ts
â”‚       â””â”€â”€ write-checker.ts
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

### package.json

```json
{
  "name": "cyberstrike-plugin-security",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "cyberstrike": {
    "plugin": true
  },
  "peerDependencies": {
    "@cyberstrike/plugin": "^1.0.0"
  }
}
```

## Hook Events

### PreToolUse

Runs before a tool executes:

```typescript
{
  event: 'preToolUse',
  matcher: 'Bash',
  handler: async (context) => {
    const { tool, args } = context;

    // Validate arguments
    if (!isValidCommand(args.command)) {
      return {
        action: 'block',
        message: 'Invalid command'
      };
    }

    // Modify arguments
    return {
      action: 'continue',
      args: {
        ...args,
        command: sanitizeCommand(args.command)
      }
    };
  }
}
```

### PostToolUse

Runs after a tool executes:

```typescript
{
  event: 'postToolUse',
  matcher: '*',
  handler: async (context) => {
    const { tool, args, result } = context;

    // Log tool usage
    await logToolUsage(tool, args, result);

    // Modify result if needed
    return {
      action: 'continue',
      result: sanitizeOutput(result)
    };
  }
}
```

### SessionStart

Runs when a session begins:

```typescript
{
  event: 'sessionStart',
  handler: async (context) => {
    // Initialize plugin state
    await initializeSession(context.sessionId);

    return { action: 'continue' };
  }
}
```

### SessionEnd

Runs when a session ends:

```typescript
{
  event: 'sessionEnd',
  handler: async (context) => {
    // Cleanup plugin state
    await cleanupSession(context.sessionId);

    // Generate session report
    await generateReport(context.sessionId);

    return { action: 'continue' };
  }
}
```

### Notification

Runs on various events:

```typescript
{
  event: 'notification',
  handler: async (context) => {
    const { type, message } = context;

    if (type === 'error') {
      await alertAdmin(message);
    }

    return { action: 'continue' };
  }
}
```

## Matcher Patterns

### Exact Match

```typescript
matcher: 'Bash'  // Only Bash tool
matcher: 'Write' // Only Write tool
```

### Wildcard

```typescript
matcher: '*'       // All tools
matcher: 'File*'   // File-related tools
```

### Array Match

```typescript
matcher: ['Bash', 'Write', 'Edit']  // Multiple tools
```

### Custom Matcher

```typescript
matcher: (tool, args) => {
  // Custom matching logic
  return tool === 'Bash' && args.command.startsWith('npm');
}
```

## Handler Actions

### Continue

Allow execution to proceed:

```typescript
return { action: 'continue' };
```

### Continue with Modifications

```typescript
return {
  action: 'continue',
  args: modifiedArgs,
  result: modifiedResult
};
```

### Block

Prevent execution:

```typescript
return {
  action: 'block',
  message: 'Operation not allowed'
};
```

### Approve

Skip permission prompt:

```typescript
return {
  action: 'approve',
  message: 'Auto-approved by policy'
};
```

## Context Object

### PreToolUse Context

```typescript
interface PreToolUseContext {
  tool: string;
  args: Record<string, any>;
  sessionId: string;
  workingDirectory: string;
  user: {
    id: string;
    permissions: string[];
  };
}
```

### PostToolUse Context

```typescript
interface PostToolUseContext {
  tool: string;
  args: Record<string, any>;
  result: {
    success: boolean;
    output: string;
    error?: string;
  };
  duration: number;
  sessionId: string;
}
```

## Configuration

### Enable Plugin

```json title="~/.cyberstrike/config.json"
{
  "plugins": [
    "cyberstrike-plugin-security",
    "./local-plugin"
  ]
}
```

### Plugin Options

```json
{
  "plugins": [
    {
      "name": "cyberstrike-plugin-security",
      "options": {
        "strictMode": true,
        "logLevel": "debug"
      }
    }
  ]
}
```

## Example Plugins

### Command Validator

```typescript
import { CyberstrikePlugin } from '@cyberstrike/plugin';

const BLOCKED_COMMANDS = ['rm -rf', 'dd if=', 'mkfs', ':(){ :|:& };:'];

export default class CommandValidator implements CyberstrikePlugin {
  name = 'command-validator';
  version = '1.0.0';

  hooks = [
    {
      event: 'preToolUse',
      matcher: 'Bash',
      handler: async ({ args }) => {
        for (const blocked of BLOCKED_COMMANDS) {
          if (args.command.includes(blocked)) {
            return {
              action: 'block',
              message: `Blocked dangerous command: ${blocked}`
            };
          }
        }
        return { action: 'continue' };
      }
    }
  ];
}
```

### Audit Logger

```typescript
import { CyberstrikePlugin } from '@cyberstrike/plugin';
import fs from 'fs/promises';

export default class AuditLogger implements CyberstrikePlugin {
  name = 'audit-logger';
  version = '1.0.0';

  hooks = [
    {
      event: 'postToolUse',
      matcher: '*',
      handler: async (context) => {
        const entry = {
          timestamp: new Date().toISOString(),
          tool: context.tool,
          args: context.args,
          success: context.result.success,
          duration: context.duration
        };

        await fs.appendFile(
          '/var/log/cyberstrike/audit.jsonl',
          JSON.stringify(entry) + '\n'
        );

        return { action: 'continue' };
      }
    }
  ];
}
```

### Secret Scanner

```typescript
import { CyberstrikePlugin } from '@cyberstrike/plugin';

const SECRET_PATTERNS = [
  /api[_-]?key\s*[:=]\s*['"][^'"]+['"]/i,
  /password\s*[:=]\s*['"][^'"]+['"]/i,
  /secret\s*[:=]\s*['"][^'"]+['"]/i,
];

export default class SecretScanner implements CyberstrikePlugin {
  name = 'secret-scanner';
  version = '1.0.0';

  hooks = [
    {
      event: 'preToolUse',
      matcher: 'Write',
      handler: async ({ args }) => {
        for (const pattern of SECRET_PATTERNS) {
          if (pattern.test(args.content)) {
            return {
              action: 'block',
              message: 'Potential secret detected in file content'
            };
          }
        }
        return { action: 'continue' };
      }
    }
  ];
}
```

## Publishing Plugins

### npm Publish

```bash
npm publish --access public
```

### Plugin Registry

Register your plugin in the Cyberstrike plugin registry for discovery.

## Best Practices

1. **Keep hooks fast** - Avoid blocking operations
2. **Handle errors** - Don't crash on plugin errors
3. **Log appropriately** - Use proper log levels
4. **Test thoroughly** - Test all hook scenarios
5. **Document behavior** - Explain what plugin does

<Aside variant="tip">
  Use the `postToolUse` hook for logging and auditing without affecting tool execution.
</Aside>

## Related Documentation

- [Hooks Overview](/docs/hooks) - Hook system basics
- [Config Hooks](/docs/hooks/config-hooks) - Configuration-based hooks
- [Creating Plugins](/docs/hooks/creating-plugins) - Plugin development guide
